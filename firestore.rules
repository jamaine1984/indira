rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    function isOwnerOrAdmin(userId) {
      return isOwner(userId) || isAdmin();
    }

    function isAdmin() {
      return isAuthenticated() &&
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.isAdmin == true;
    }

    function isValidUser() {
      return isAuthenticated() &&
             request.auth.token.email_verified == true;
    }

    function hasValidSubscription() {
      return isAuthenticated() &&
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.subscriptionTier in ['silver', 'gold'];
    }

    function isNotBlocked(userId) {
      return !exists(/databases/$(database)/documents/blocked_users/$(request.auth.uid + '_' + userId)) &&
             !exists(/databases/$(database)/documents/blocked_users/$(userId + '_' + request.auth.uid));
    }

    function canSendMessage(matchId) {
      return isAuthenticated() &&
             request.auth.uid in get(/databases/$(database)/documents/matches/$(matchId)).data.users;
    }

    // Input validation functions
    function isValidString(text, maxLength) {
      return text is string && text.size() <= maxLength;
    }

    function isValidMessage(data) {
      return isValidString(data.text, 1000) &&
             data.senderId == request.auth.uid &&
             data.timestamp == request.time;
    }

    // Users collection
    match /users/{userId} {
      // Users can read their own full profile
      allow read: if isOwner(userId);

      // Other authenticated users can read limited public profile data
      allow read: if isAuthenticated() && isNotBlocked(userId);

      // Users can create their own profile
      allow create: if isOwner(userId);

      // Users can update their own profile (restricted fields)
      allow update: if isOwner(userId) &&
                       !request.resource.data.diff(resource.data).affectedKeys()
                       .hasAny(['isAdmin', 'verificationStatus', 'isVerified']);

      // Only admins can delete user accounts
      allow delete: if isAdmin();

      // Usage subcollection for tracking daily limits
      match /usage/{dateKey} {
        allow read, write: if isOwner(userId);
      }
    }

    // Likes collection - secure but queryable
    match /likes/{likeId} {
      // Allow read if user is involved in the like
      allow read: if isAuthenticated() &&
                     (resource.data.likerId == request.auth.uid ||
                      resource.data.likedUserId == request.auth.uid);

      // Allow listing for queries with proper filters
      allow list: if isAuthenticated();

      // Allow create if authenticated and data is valid
      allow create: if isAuthenticated() &&
                       request.resource.data.likerId == request.auth.uid &&
                       isNotBlocked(request.resource.data.likedUserId);

      // Allow update only for match status
      allow update: if isAuthenticated() &&
                       (request.auth.uid == resource.data.likerId ||
                        request.auth.uid == resource.data.likedUserId) &&
                       request.resource.data.diff(resource.data).affectedKeys()
                       .hasOnly(['isMutualMatch', 'isRevealed', 'revealedAt']);

      // Allow delete only by liker
      allow delete: if isAuthenticated() &&
                       request.auth.uid == resource.data.likerId;
    }

    // Swipes collection - track all swipes
    match /swipes/{swipeId} {
      allow list: if isAuthenticated();
      allow read: if isAuthenticated() &&
                     resource.data.userId == request.auth.uid;
      allow write: if isAuthenticated() &&
                      request.resource.data.userId == request.auth.uid;
    }

    // Matches collection
    match /matches/{matchId} {
      allow read: if isAuthenticated() &&
                     request.auth.uid in resource.data.users;
      allow create: if isAuthenticated();
      allow update: if isAuthenticated() &&
                       request.auth.uid in resource.data.users;
      allow delete: if false; // Never allow deletion of matches

      // Messages subcollection - encrypted messages only
      match /messages/{messageId} {
        allow read: if canSendMessage(matchId);
        allow create: if canSendMessage(matchId) &&
                         isValidMessage(request.resource.data);
        allow update: if canSendMessage(matchId) &&
                         request.resource.data.diff(resource.data).affectedKeys()
                         .hasOnly(['readAt', 'deliveredAt']);
        allow delete: if false; // Messages cannot be deleted
      }
    }

    // Social Posts - with content moderation
    match /social_posts/{postId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() &&
                       request.resource.data.userId == request.auth.uid &&
                       isValidString(request.resource.data.content, 500);
      allow update: if isOwner(resource.data.userId) &&
                       request.resource.data.diff(resource.data).affectedKeys()
                       .hasOnly(['content', 'editedAt']);
      allow delete: if isOwner(resource.data.userId) || isAdmin();
    }

    // Gifts collection - read only
    match /gifts/{giftId} {
      allow read: if isValidUser();
      allow write: if isAdmin();
    }

    // User gifts (sent gifts)
    match /user_gifts/{giftId} {
      allow read: if isAuthenticated() &&
                     (request.auth.uid == resource.data.userId ||
                      request.auth.uid == resource.data.senderId ||
                      request.auth.uid == resource.data.receiverId);
      allow create: if isAuthenticated() &&
                       (request.auth.uid == request.resource.data.userId ||
                        request.auth.uid == request.resource.data.senderId);
      allow update: if isAuthenticated() &&
                       (request.auth.uid == resource.data.userId ||
                        request.auth.uid == resource.data.receiverId) &&
                       request.resource.data.diff(resource.data).affectedKeys()
                       .hasOnly(['isOpened', 'openedAt']);
      allow delete: if false;
    }

    // Reports collection
    match /reports/{reportId} {
      allow create: if isAuthenticated() &&
                       request.resource.data.reporterId == request.auth.uid &&
                       isValidString(request.resource.data.reason, 500);
      allow read: if isAuthenticated() &&
                     (request.auth.uid == resource.data.reporterId || isAdmin());
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }

    // Blocked users collection
    match /blocked_users/{blockId} {
      allow create: if isAuthenticated() &&
                       request.resource.data.blockerId == request.auth.uid;
      allow read: if isAuthenticated() &&
                     (request.auth.uid == resource.data.blockerId ||
                      request.auth.uid == resource.data.blockedUserId);
      allow delete: if isAuthenticated() &&
                       request.auth.uid == resource.data.blockerId;
      allow update: if false;
    }

    // Verification requests - secure storage
    match /verification_requests/{requestId} {
      allow create: if isAuthenticated() &&
                       request.resource.data.userId == request.auth.uid;
      allow read: if isAuthenticated() &&
                     (request.auth.uid == resource.data.userId || isAdmin());
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }

    // Purchases collection - IAP tracking
    match /purchases/{purchaseId} {
      allow create: if isAuthenticated() &&
                       request.resource.data.userId == request.auth.uid;
      allow read: if isAuthenticated() &&
                     (request.auth.uid == resource.data.userId || isAdmin());
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }

    // Notifications
    match /notifications/{notificationId} {
      allow read: if isAuthenticated() &&
                     request.auth.uid == resource.data.userId;
      allow create: if isAuthenticated();
      allow update: if isAuthenticated() &&
                       request.auth.uid == resource.data.userId &&
                       request.resource.data.diff(resource.data).affectedKeys()
                       .hasOnly(['read', 'readAt']);
      allow delete: if isAuthenticated() &&
                       request.auth.uid == resource.data.userId;
    }

    // Analytics - write only for users, read for admins
    match /analytics/{analyticId} {
      allow create: if isAuthenticated();
      allow read: if isAdmin();
      allow update: if false;
      allow delete: if false;
    }

    // Admin audit logs - admins only
    match /audit_logs/{logId} {
      allow read: if isAdmin();
      allow create: if isAdmin();
      allow update: if false;
      allow delete: if false;
    }

    // Legal documents - public read
    match /legal/{documentId} {
      allow read: if true;
      allow write: if isAdmin();
    }

    // App configuration - public read
    match /config/{configId} {
      allow read: if true;
      allow write: if isAdmin();
    }
  }
}